#
# Серверное приложение для соединений
#
"""
    Сервер будет асинхронный.
    В качестве подготовительных данных должны присутствовать два класса:
        - Отвечает за серверную часть управления соединениями. Сервер запускается и в
        конце останавливается
        - Отвечает за соединение между сервером и клиентом. Клентский класс будет постоянно
        создаваться на каждого нового подключившегося клиента

    class ServerProtocol:
        pass - заглушка, не несет никакого логического смысла, знак того, что здесь нужно дописать код

================================================= Теория =================================================
    Для обмена данными между компьютерами используется сеть. В сети существуют несколько протоколов.
Протокол - это некий набор правил и стандартов как выглядит сообщение и в каком формате оно передается на
другой ПК. В интернете вся информаия передается в виде байт. Отправлять мы можем только байты и принимать
мы можем только байты, а вот внутри этих байтов может быть уже строка, стикер и т.п.
    Существуют два основных протокола передачи данных для приложений типа чата, удаленных баз данных и т.п.
    1) UDP - нестабильный в плане качества передачи данных, но он очень быстрый. Предназначен для передачи
    потоковой графики, онлайн трансляций и т.д.
    2) TCP - более надежный, предназначен для отправки сообщений. Если не получилось отправить сообщение,
    то он попробует отправить его снова, если скорости не хватает - он все равно доставит это сообщение и
    если, что-то пошло  не так то он сообщит вам об этом
==========================================================================================================

class ServerProtocol - класс, который опишет наш собственный протокол передачи данных между ТСР клиентами
(клиентом и сервером)

class Server - программа для запуска

[1] - Конструктор протокола. Указывается не просто передачей туда параметра, а передачей именно функции
конструктора, что бы он мог вызвать построение объекта на нового клиента. Для этого создатим еще одну
функцию (метод)     def build_protocol(self): - постоение нового протокола
                          return ServerProtocol(self) - вернуть новый объект класса ServerProtocol,
                          который будет связан с текущей реализацией сервера
[2] - await отличается от return тем, что оно не просто возвращает значение из функции, оно возвращает
значение в то место, где вы вызвали эту конструкцию
"""

import asyncio
from asyncio import transports
from typing import Optional


class ServerProtocol(asyncio.Protocol):
    login: str = None  # По умолчанию None
    server: 'Server'  # Так уазывается тип сервера, которого еще не существует на момент написания этой строки
    transport: transports.BaseTransport
    """
    На стадии инициализации протокола мы должы знать все о нашем сервере, по-этому лучшим способом будет сразу
    его и получить 
    """

    def __init__(self, server: 'Server'):
        self.server = server

    """
    def data_received(self, data: bytes) - автоматически вызовется протоколом, когда мы получили какие-то данные 
    по сети и эти данные называются data с типом данных bytes
    """

    def data_received(self, data: bytes):
        print(data)
        """
        Необходимо декодировать данные для того, что бы работать с ними как со строкой 
        """
        decoded = data.decode()  # Декодировка данных, полученных по сети. Там будет находиться строка текста

        if self.login is not None:
            self.send_message(decoded)
        else:
            """
            Если  строка, которую нам прислал пользователь, начинается с "login:", то мы из нее убираем "login:", 
            сохраняем оставшуюся часть как логин и высылаем ему сообщение 
            """
            if decoded.startswith("login:"):
                self.login = decoded.replace("login:", "").replace("\r\n", "")
                if (self.login in self.server.clients):
                    self.transport.write(
                        f"Ошибка! Логин: <{self.login}> занят другим пользователем."
                    )
                else:
                    self.transport.write(
                        f"Привет, {self.login}!\n".encode()
                    )
            else:
                self.transport.write("Неправильный логин\n".encode())

    """
    connection_made(self, transport: transports.BaseTransport) - работает в том случае, если успешно установили 
    соединение и в качестве аргумента сюда приходит transport с типом данных transports.BaseTransport
    transport - это слой, через который мы можем общаться между двумя разными клиентами (то же самое что и чат), 
    туда можно писать и от туда можно считывать
    """

    def connection_made(self, transport: transports.BaseTransport):
        self.server.clients.append(self)  # Текущий протокол(self).ссылка на базовый процесс, который запущен и только
        # в конце остановиться(server).список клиентов, который мы объявили чуть ниже(clients).добавляем в этот
        # список текущее соединение(append(self))
        self.transport = transport  # Поток для передачи сообщений

        print("Пришел новый пользователь")

    """
    connection_lost(self, exception) - в случае разрыва соединения мы будем получать специальный аргумент exceptoin.
    Если разрыв получился в результате ошибки, если клиент сам отключился - там будет пусто 
    """

    def connection_lost(self, exception):
        self.server.clients.remove(self)  # Удаляем пользователя, который отключился

        print("Пользователь вышел")

    def send_message(self, content: str):
        message = f"<{self.login}> {content}\n"

        for user in self.server.clients:
            user.transport.write(message.encode())


class Server:
    clients: list  # Список, для хранения пользователей. Написали что может быть список, но это не факт, что он уже есть

    def __init__(self):
        self.clients = []  # При старте сервера, список клиентов должен быть пустым. Инициализация списков.
        # Создали пустой список, что бы он  всегда был и мы могли добавлять туда новых клиентов

    def build_protocol(self):
        return ServerProtocol(self)

    async def start(self):
        loop = asyncio.get_running_loop()  # Обращаемся к модулю asyncio и говорим ему: "вери мне текущий, работающий цикл"
        # Получим управление событейным циклом (loop). Коробочка в которую мы складываем задачи, а питон их потом
        # распределяет

        """
        Создание сервера - это асинхронная операция иначе мы бы просто зависли на этом моменте, по-этому создать сервер 
        надо где то в фоне, а продолжить работу с программой в первом потоке. По-этому перед loop необходимо слово await
        """
        coroutine = await loop.create_server(
            self.build_protocol,  # Конструктор протокола [1]
            '127.0.0.1',  # Host. IP адрес сервера на котором будет запущена программа
            8888  # Задаем номер порта (только выше 1024). Порт - аналог радиочастотам
        )  # Обращаемся к циклу и коворим ему: "создай мне сервер"

        print("Сервер запущен...")
        await coroutine.serve_forever()  # Запуск сервера [2]


process = Server()
try:  # try - попробуй
    asyncio.run(process.start())
except KeyboardInterrupt:  # except - перехватить
    print("Сервер остановлен вручную.")
